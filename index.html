<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qiu-jp.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="邱的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="测试">
<meta property="og:url" content="https://qiu-jp.github.io/index.html">
<meta property="og:site_name" content="测试">
<meta property="og:description" content="邱的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Qiu Junpeng">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://qiu-jp.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>测试</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">测试</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Qiu Junpeng</p>
  <div class="site-description" itemprop="description">邱的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qiu-jp.github.io/2025/04/08/Neural-Video-Codecs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiu Junpeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试">
      <meta itemprop="description" content="邱的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 测试">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/08/Neural-Video-Codecs/" class="post-title-link" itemprop="url">Neural-Video-Codecs</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-04-08 23:26:57 / 修改时间：23:28:07" itemprop="dateCreated datePublished" datetime="2025-04-08T23:26:57+08:00">2025-04-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文介绍非传统方法的视频编码器发展。</p>
<p>第一篇聚焦于使用深度学习方法的端到端视频压缩模型来源于CVPR2019论文，DVC: An End-to-end Deep Video Compression Framework。作者提出，传统的视频编码器主要由多个模块组成，例如：运动估计、DCT变换、量化等各模块紧密耦合工作，实现减少视频中的信息冗余的功能。但是图像压缩的相关研究进展说明，在图像压缩领域，DNN具有相当强大的潜力，通过合理的结构可以实现端到端的压缩，并且与传统图像编码器如JPEG等性能相当。这是因为DNN可能具有传统方法所不具备的强大的端到端训练能力和高度非线性化变换的能力，但是直接将DNN应用在视频压缩领域中存在以下几个问题：1. 视频压缩中最大的信息冗余来自于视频中的运动信息，如何识别、生成并压缩这一信息？2. 如何构建以码率—失真代价这一指标作为标准的DNN视频压缩系统？</p>
<p>因此本文作者提出了Deep Video Compression（DVC）模型，该模型的最大特点为：</p>
<p>1、将传统视频压缩框架中的关键组成部分如：运动估计、运动补偿、残差压缩、运动压缩、量化、码率估计等功能全部融入一个端到端的神经网络结构。</p>
<p>2、该网络是基于码率—失真代价做优化训练的。</p>
<p>3、在该DVC模型中，网络结构并不是非常抽象的，而是与传统视频压缩框架中的关键结构一一对应的，可以很方便地进行修改工作。</p>
<p>具体的网络结构和传统视频压缩结构如下：</p>
<p><img src="/2025/03/20/VVC-1/-Video-Codecs/figure1.png" alt="network structure"></p>
<p>在传统视频编码框架中，各模块的行为是基于基本单元的编码块，整体的流程可被概括为一个预测-变换框架。在编码当前帧时（P帧），编码器需要根据其参考帧进行基于块的运动估计和运动补偿以实现帧间预测，消除视频序列的时域信息冗余。参考帧来自于在当前编码帧之前已完成编码并解码获得的重建帧，根据特定算法获得当前待编码帧的每一个块的的运动矢量，根据运动矢量预测待编码块的预测帧，预测帧和原始帧的残差即为所需编码的残差。因此，需要编码的信息从原来的完整帧的信息减少为单帧中每一个块的运动矢量和残差，残差值会经过变换量化与运动矢量最终通过熵编码模块生成码流。在解码过程中，通过反变换和反量化获得原始残差信息，结合运动矢量和参考帧获得预测帧即可进行帧的重建。</p>
<p>在右图作者提出的基于深度学习的编码框架中，可以看到传统编码器的各功能均存在一对一的对应网络结构。</p>
<p>一、运动信息的获取</p>
<p>在考虑当前编码帧与参考帧之间的关系时，该网络结构通过一个CNN结构去预测光流，光流表示即作为视频中的运动信息表示，由于光流的原始值可能需要使用较大的比特数，因此通过一个MV编码网络将原始光流值进行压缩和量化，对应的存在一个MV解码网络用以获得重建的运动信息。该网络结构如下：</p>
<p><img src="/2025/03/20/VVC-1/-Video-Codecs/figure2.png" alt="mv network"></p>
<p>可以看出是个很典型的编码器-解码器结构，类似U-net，中心思想是通过卷积层和非线性变换提取整幅图像的特征。对于M X N X 2的光流表示，4层卷积层会将其压缩为M&#x2F;16 X N&#x2F;16  X 128的表示，再通过量化得到最终表示。最终表示即被量化过的表示是要被送进熵编码结构形成码流的，具体的数据结构unclear（TODO：通过源代码去看细节）。与传统编码器对于运动信息的处理结构区别在于，传统编码器将运动信息表征为运动矢量，运动矢量的关键是用来做预测以计算残差，所以运动矢量是必要的需要被编码的信息。传统编码器中涉及运动矢量及相关计算的模块有：1. 运动矢量的得出，是传统编码器计算复杂度的重大来源之一 2. 运动矢量需要帮助去做预测帧的计算。 3. 码流中对于运动矢量的解码。 该网络的改动可对应看到：1.运动信息的表示采用光流，即原运动矢量的得出在该结构中为光流网络，参考自End-to-end optimized image compression。2. 该编码器结构将原始光流信息压缩出的运动信息表示送去编为码流，即类似变换量化的处理概念，但是通过什么学习是一个问题，它是如何知道压缩完应该是什么样的形式呢（TODO）。 3.解码器结构就是将中间运动表示还原成光流，从结构图中可以看出，它是将光流信息应用于后续的类似传统编码器的预测操作（消除冗余），即光流信息是怎么用来得到传统编码器的残差这一概念的，可以看后续具体结构。</p>
<p>二、运动补偿</p>
<p><img src="/2025/03/20/VVC-1/-Video-Codecs/figure3.png" alt="motion compensation network"></p>
<p>运动补偿网络用以模拟传统编码器中获得预测帧的过程，这一过程即是在消除视频的时域冗余信息。该网络首先将解码后光流信息和参考帧warp成一张完整图像（TODO:怎么做的），再与光流信息和参考帧concatenate成一个三维度特征输入CNN网络中，最终得到预测帧。这样的一个运动补偿的方法是不基于块的，好处在于可以规避传统方法所导致重建块与块之间的分裂（去除环路滤波器），并且相比基于传统方法中给定的运动矢量和预测帧生成方法，也许深度学习方法的效果会更好。（上限更高）（TODO：训练过程中直观地应希望预测帧与原始帧尽可能接近使得残差最小码率最小，不过本篇文章为端到端的框架，可能是所有的模块获得结果后统一根据RD-Cost进行训练）</p>
<p>MC内部的CNN结构如下，也是类似U-Net的编码器解码器结构，先通过卷积和池化层缩小特征图尺寸得到特征表示，再通过上采样和反卷积进行特征解码获得参考帧，解码过程中也获得了编码过程中不同尺寸的特征以丰富特征信息。</p>
<p><img src="/2025/03/20/VVC-1/-Video-Codecs/figure4.png" alt="mc cnn network"></p>
<p>三、残差编码</p>
<p>采用论文Variational image compression with a scale hyperprior中的高度非线性网络将残差表示为潜在表示，相比于传统算法的好处在于利用更多非线性特性可以达到更好的压缩效率。</p>
<p>四、训练方法</p>
<p>损失函数考虑R-D Cost。</p>
<p>λD + R &#x3D; λd(xt, xˆt) + (H( ˆmt) + H(ˆyt))</p>
<p>五、量化方法</p>
<p>在熵编码前需要进行量化，训练阶段对需量化的量如残差和运动信息添加噪声，推理阶段直接向下取整。</p>
<p>六、码率估计</p>
<p>在考虑R-D Cost的时候需要估计潜在表示的码率，码率估计的方法应是这些潜在表示的熵。为了避免传统方法的计算，可以通过CNN网络估计潜在表示的概率，从而获得其对应的熵。CNN结构采用论文Variational image compression with a scale hyperprior。</p>
<p>总结：该篇论文作为深度学习端到端编码器的起始工作，整体的设计思路较为明确，即仿照传统编码器的结构将各功能替换为深度学习方法实现。</p>
<p>第二篇论文题为Towards Practical Real-Time Neural Video Compression，发表于2025年的CVPR，该篇文章主要实现实时的神经网络视频编解码器。神经网络编解码器（Neural Video Codec）的编码时间主要在于计算代价和非计算的操作代价，包括存储输入输出和功能调用等，以往的工作主要专注于运算代价的减少，但该篇文章主要关注如何减少操作代价。</p>
<p>本文主要的贡献有：</p>
<ol>
<li>本文采用一种隐含的时域信息建模方法取代复杂的显式运动表示模块</li>
<li>本文采用单一的低分辨率隐含表示取代逐步下采样。</li>
<li>本文采用模型整数化方法以实现一致的跨设备编码和基于模块组的码率控制方案以提高适应性。</li>
</ol>
<p>本文所提出的DCVC-RT结构见下图。</p>
<p><img src="/2025/03/20/VVC-1/-Video-Codecs/figure5.png" alt="DCVD-RT"></p>
<p>在编码具体一帧时，首先该帧图像先会进行1&#x2F;8精度的小图划分，再映射为一维向量，即patch embedding操作，详见（An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale）。</p>
<p>一、Conditional Coding（TODO：CANF-VC: Conditional augmented normalizing flows for video compression；Deep contextual video compression；Neural Video Compression with Feature Modulation）</p>
<p>二、Latents at low Resolution</p>
<p>常用的编码器在处理网络中每一层的隐含表示时，是通过逐步的降采样以减小隐含表示的维度，往往所做的操作是每一层减半隐含表示的大小同时加倍其通道数。（直观在卷积层中的体现即为stride为2，同时卷积核个数翻倍）在本文中，作者提出为了加速编码速度，直接将一帧图像进行低分辨率的划分，在每一块划分中进行Conditional Coding，相比于对完整的一帧图像进行逐步降采样的编码，在0.3%的BD-Rate性能损失下达到3.6倍的加速。（TODO：这一块的感受野论述有点迷）</p>
<p>三、隐含的时域信息建模</p>
<p>作者研究发现，传统的运动模块在网络层数上占用很大，但实际上相比起Conditional Coding并没有带来很巨大的运算复杂度，因为运动是易于压缩的，因此对于这样的低运算复杂度模块，应聚焦于减小过多的网络层所带来的操作复杂度。</p>
<p>因此，作者不在考虑使用网络去表征出具体的运动信息，而是通过简单的特征提取网络提取时域上的关联即可。（TODO：具体提取的细节要看代码）</p>
<p>四、码率控制</p>
<p>码率控制是根据量化参数进行的，网络会学习一系列超先验的模块，这些模块能够模拟不同量化参数下的隐含表示的概率分布。通过类似的方法，也可以对每一个模块进行学习，得到相应的向量库。每个向量库都旨在学习一组向量，这些向量能够根据隐含表示的特征自适应地对其进行缩放，从而实现灵活且精细的幅度调整。（幅度调整即体现为乘法）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qiu-jp.github.io/2025/04/08/Fast-Partition-Dev/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiu Junpeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试">
      <meta itemprop="description" content="邱的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 测试">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/08/Fast-Partition-Dev/" class="post-title-link" itemprop="url">Fast_Partition_Dev</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-08 20:11:38" itemprop="dateCreated datePublished" datetime="2025-04-08T20:11:38+08:00">2025-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-09 05:12:44" itemprop="dateModified" datetime="2025-04-09T05:12:44+08:00">2025-04-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文介绍并回顾视频编解码中快速划分算法的发展，主要聚焦于新兴的机器学习方法，对比各方法的不同划分表征方式和后处理模式。</p>
<p>在HEVC视频编解码标准下，划分方法仅存在QT四划分。在视频编码的过程中，决定一个CTU块的划分是一个自上而下的迭代过程。编码器会从最大的CTU块开始执行判决，计算划分与不划分两种情况分别的代价，选择代价更小的方式。若判决需要划分，则QT四划分会将原64x64的编码块划分为四个32x32的编码块，在迭代进行是否划分的判决，直至编码块大小达到规定最小尺寸或CTU中的各子CU编码块均判决为不再划分。在这一判决过程中，代价计算综合了码率和失真这两要素，广泛采用SAD或SATD代价，计算公式如下。</p>
<p>因此，这一过程被称为RDO过程，即Rate-Distortion Optimization。在RDO过程中，一个编码块的代价计算应为其所有子编码块代价之和，即划分情况下，编码块的代价应为各子划分块的代价；不划分情况下，编码块的代价则以当前编码块的尺寸进行数学计算。因此，可以发现，RDO过程是通过不断地迭代计算得到所有划分情况的代价，整体的迭代过程是自顶向下的，而代价计算和判断是自下向上的。</p>
<p>在VVC标准中，正式引入了QTMT划分。QTMT划分在四叉树的基础上增加了二叉树和三叉树的划分方式，因此VVC中RDO的划分判决共有6类，BTH划分、BTV划分、QT划分、TTH划分、TTV划分和不划分，相比于原有的划分种类扩展了近3倍，再带来编码性能提升的同时大大增加了RDO判决的复杂度，是编码过程中极耗时的部分。因此，相关的工作主要集中于快速编码算法的发展。这些快速编码算法只要可分为两种思路，一种是传统的基于统计学的剪枝算法，根据一定的图像块特征和模式的统计学结果减少需要检索的划分类型或提前中止划分。另一种是基于机器学习的AI算法，对于视频各帧的处理即为对于一张完整图像的处理，因此计算机视觉领域的相关思路和算法模式可被应用其中。</p>
<p>（一）<br>来自ICIP 2018的Fast QTBT Partitioning Decision for Interframe Coding with Convolution Neural Network是最早将卷积神经网络应用于帧间QTBT快速划分判决的工作。本篇文章中卷积神经网络的结构是作者对于QTBT划分结果进行统计学分析从而得到启发。</p>
<p>首先，在整体网络任务上，将快速划分问题归类为多分类问题。然而，由于不同的划分会产生不同尺寸的图像，难以设计一个统一的网络接受不同尺寸的输入并进行分类，因此作者通过统一的深度表示来对QTBT划分结构进行建模。深度定义为，QT深度的两倍叠加BT深度。（注意，该篇文章为HEVC到VVC的过渡阶段工作，此时仅引入BT划分，不存在MT划分）最大CTU块规定为128x128，最小QT划分块规定为16x16，故最大QT深度为3，最小CU尺寸为4x4，故最大BT划分深度规定为4，（先进行完QT划分才会执行BT划分），总QTBT统一深度的取值范围为0到10。这一统一深度的表示是指所考虑的CU块中的最大深度，即如果CU块中存在需要划分到最小尺寸4x4的情况，那么该CU块的统一深度表示即为10。因此，很容易理解这样一个统计学事实，即128x128尺寸的CU的统一深度表示会在分布上存在偏差，有将近50%的情况需要划分到最大深度，因为CU的尺寸很大，所包含的纹理空间也相应很大，存在复杂纹理的情况也更加普遍。而对于64x64尺寸的CU和32x32尺寸的CU来说，统一深度表示的分布更加平均，因为小尺寸纹理空间包含的范围更小，出现复杂纹理和平滑纹理的情况更加平均，适合用来训练。最终本文选取64x64尺寸的CU作为输入，并且为了避免过拟合，将深度进行归类形成待分类的种类。</p>
<p><img src="/2025/03/20/VVC-1/artition-Dev/image-20250331163346677.png" alt="image-20250331163346677"></p>
<p>具体的CNN网络结构见下图，</p>
<p><img src="/2025/03/20/VVC-1/artition-Dev/image-20250331163245256.png" alt="image-20250331163245256"></p>
<p>首先前处理执行一个简单的运动补偿过程获得待编码块的参考块，相减得到残差块，残差块隐含视频序列的时域冗余信息，相比原始参考块像素是更有力的特征表示。残差块减去平均值后作为网络输入，经过三层卷积层提取特征并最终连接展平为一个特征向量，随后考虑量化参数qp和参考的时域层数两个特征，将三者进行非线性地融合并通过全连接层输出分类结果。损失函数考虑网络权重矩阵的大小和分类结果与原始结果的差值（即准确率）。</p>
<p>获得分类结果后，快速划分的后处理方法如下：</p>
<p><img src="/2025/03/20/VVC-1/artition-Dev/image-20250331165615216.png" alt="image-20250331165615216"></p>
<p>对于一个CTU进行划分判决时，首先会直接将128x128大小的CU划分为64x64大小的子块，根据网络推理结果得到对应子块的最大划分深度$d_i$。然后，对于参考块也进行类似操作，得到对应参考块的预测最大划分深度$d_i^{‘}$，由于参考块是已编码重建块，故实际最大划分深度已知为$D_i^{‘}$。</p>
<p>修正子块的预测深度为<br>$$<br>\begin{equation}<br>d_i&#x3D;d_i+max \{ D_i^{‘}-d_i^{‘},0 \}<br>\end{equation}<br>$$<br>含义为：若参考块预测正确，则接受子块的预测结果；若参考块预测值偏大，则保留子块的偏大预测结果以保证足够划分深度用以进行判决；若参考块预测值偏小，则子块预测值需进行补偿。</p>
<p>获得四个子64x64块的预测深度后，原128x128CTU块将根据预测深度开启划分判决。若四个子块预测深度均为0，说明最小划分尺寸为64x64，因此128x128尺寸的CTU块将进行深度不超过2的划分判决以决定最佳划分模式。若仅存在一个子块预测深度不为0，则128x128尺寸的CTU块将正常执行QTBT划分判决，只是64x64子块的划分无需判断提前终止。若多个子块预测深度不为0，那么128x128尺寸CTU块会直接执行QT划分，然后对应64x64子块会根据预测划分深度进行判定和提前终止。</p>
<p>总结：本文的工作作为HEVC到VVC的过度工作被纳入VVC的标准中，但由于时间比较久远，从现在VVC的QTMT划分结构的角度来看，本文提出的统一深度表示不再能表示复杂的QTMT结构。不过本文的思想值得进行归纳，首先需明确网络的多分类任务是针对单个块的纹理复杂度进行粗分，最终仅能得到反映编码块整体深度的一个粗糙表示，在后处理中服务于划分判决的提前终止（剪枝思想）。更加理想的多分类任务应针对划分模式进行预测，从而可以获得更加细节的表示。在本文所提出的后处理结构中，针对64x64及更小尺寸的块划分并没有加速，这也是这一整体性深度表示方法的劣势。</p>
<p>（二）<br>来自IEEE SIGNAL PROCESSING LETTERS, VOL. 28, 2021的A CNN-Based Fast Inter Coding Method for VVC提出了基于CNN的CU划分提前终止算法和模式快速决策算法。</p>
<p>在该篇论文中，CU划分问题被建模为一个二分类问题，采用一个多特征输入的网络结构以解决分类问题，称为multi-information fusion CNN(MF-CNN)。具体的网络结构如下图。</p>
<p><img src="/2025/03/20/VVC-1/artition-Dev/inter2-1.png" alt="网络结构"></p>
<p>网络接受三个输入：待编码帧的原始亮度输入；对待编码帧进行运动估计后得到的残差输入；运动估计后得到的双向运动场输入。三个输入分别通过独立的AKCG(Asymmetric Kernel Convolution Group)（TODO）提取横向和纵向的特征，再通过两层卷积层进行学习以及卷积块注意力模型(CBAMs,Convolution Block Attention Modules)去强化特征学习。由三个输入所分别学习到的特征会被连接并通过卷积层、残差注意力模块(Residual Attention Module,RES-CBAM)和卷积层以汇聚特征，最终通过平均池化层获得二分类的结果。</p>
<p>由于CU划分问题被建模为二分类问题，因此该网络最终的目的仅用于判断输入尺寸的CU是否需要被划分，若需要被划分，则进行常规的RDO过程进行判决；若无需划分，则可提前终止。因此后处理中，需要在RDO的迭代过程中对各尺寸子CU进行网络推理并根据推理结果决定RDO的迭代方向，推理结果根据其置信度和人为预设的阈值判断是否被接受，设定当CU大小为128x128时，阈值为1，其他大小的CU阈值为0.95。网络推理这一过程被反复执行，当CU的长度或宽度小于16时，不再进行网络推理。值得注意的是，由于原始输入的尺寸是不固定的，因此第一层需要采用AKCG已提取特征并规范化特征块的大小，本文将输入CU块的大小划分为三组：Type-1{128x128,128x64,64x128},Type-2{64x64,64x32,32x64,64x16,16x64},Type-3{32x32,32x16,16x32,16x16}。对应的AKCG核大小定义如下表。</p>
<p><img src="/2025/03/20/VVC-1/artition-Dev/inter2-2.png" alt="表格1"></p>
<p>损失函数可分为两部分，第一部分为基础的交叉熵损失函数，第二部分用以表征RDO代价。公式如下。</p>
<p><img src="/2025/03/20/VVC-1/artition-Dev/inter2-3.png" alt="公式"></p>
<p>总结：该网络的使用是用以判断是否需提前终止所输入的CU块的划分判决，无法进行最终的划分结构预测，具有一定局限性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qiu-jp.github.io/2025/03/20/%E5%A4%87%E6%B3%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiu Junpeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试">
      <meta itemprop="description" content="邱的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 测试">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/20/%E5%A4%87%E6%B3%A8/" class="post-title-link" itemprop="url">备注</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-20 02:34:36" itemprop="dateCreated datePublished" datetime="2025-03-20T02:34:36+08:00">2025-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-25 23:47:56" itemprop="dateModified" datetime="2025-03-25T23:47:56+08:00">2025-03-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>git pull origin hexo  &#x2F;&#x2F;先pull完成本地与远端的融合<br>hexo new post “new blog name”<br>git add source &#x2F;&#x2F; git add .<br>git commit -m “XX”<br>git push origin hexo<br>hexo d -g</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qiu-jp.github.io/2025/03/20/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiu Junpeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试">
      <meta itemprop="description" content="邱的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 测试">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/20/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-20 02:29:27" itemprop="dateCreated datePublished" datetime="2025-03-20T02:29:27+08:00">2025-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qiu-jp.github.io/2025/03/20/VVC-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiu Junpeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试">
      <meta itemprop="description" content="邱的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 测试">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/20/VVC-1/" class="post-title-link" itemprop="url">VVC(1)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-03-20 02:19:44 / 修改时间：02:29:27" itemprop="dateCreated datePublished" datetime="2025-03-20T02:19:44+08:00">2025-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>VVC官方测试软件VTM代码分析<br>从可以下载VTM代码，本文的具体分析对象为VTM10.0<br>VTM的源码可以在source文件夹中找到，具体分成两部分App和Lib。App文件夹下包含了VTM的应用程序，即实现了编码器和解码器开始编解码过程后的具体行为，包括程序运行主函数。EncoderApp和DecoderApp下各有一个CMakeLists.txt用以编译，最后可得到两个可执行文件EncoderApp和DecoderApp分别作为编码器和解码器的功能调用接口。Lib文件夹中包含了各种编码器和解码器所需使用的功能库和数据结构。<br>进入EncoderApp文件夹中通过encmain.cpp可以具体研究编码器的行为逻辑，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qiu-jp.github.io/2024/03/20/%E4%B8%80%E3%80%81Linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiu Junpeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试">
      <meta itemprop="description" content="邱的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 测试">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/20/%E4%B8%80%E3%80%81Linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">一、Linux环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-20 02:08:59" itemprop="dateCreated datePublished" datetime="2024-03-20T02:08:59+08:00">2024-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-20 02:33:45" itemprop="dateModified" datetime="2025-03-20T02:33:45+08:00">2025-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>写在最前面：<br>这一栏目主要是记录一些环境配置和常用工具的所有基础准备，因为我发现这些东西虽然非常基础但其实自己一个人入门的话还是有一些阻碍的。特别是对于自己一个非计算机的学生来说，本科的课程往往在教一些落于笔头的的电路计算和设计，仿真直接下载三大公司提供的EDA工具使用，确实没有积累起一个完整的系统的代码开发环境和平台。细细回忆起来整个本科生涯一共就接触过三门比较软的代码课，分别是c++和python，那时候以为c++就得下工具visual studio，python就得下工具pycharm，至于linux系统，应该就是我要用服务器的时候才会用到吧。结果后来和计算机的同学一起自习，发现人家打开一个vs code就可以运行各式各样的代码，我也照葫芦画瓢打开vscode写了一个hello world结果就跟个记事本一样完全无法运行（笑）。甚至以前最开始的时候从github上下载东西也不会用git下载，下载下来一个压缩包解压打开找不到visual studio工程就不知道如何运行。那个时候确实是非常无知了，但又内心暗自觉得这些只是是最基础的部分又不好意思去问只能在网上像无头苍蝇一样检索，所以我觉得把这样的一个基础环境的配置和搭建总结下来还是很有必要的。这些各种工具的教程其实细细搜索网上会更加全面，这里就当一个搬运总结好了，顺便自己下次换电脑重新配环境时也有个指导。</p>
<p>第一部分主要是linux环境的配置和本人最喜欢的编辑器vs code的使用。因为linux环境对于很多开源工程来说还是很必要的，往往来说比windows环境的适配性要更好一些，所以主要还是采用linux环境去做一个开发。由于我们平时买到的电脑大多还是windows系统，因此以往比较推荐的方法主要是在电脑中再配置一个linux的虚拟机实现一个双系统，不过虚拟机和本地之间互相传输文件以及打开关闭虚拟机还是一个很麻烦的事情，所以不如使用最新的wsl2工具，可以理解为wsl2就是microsoft提供了一个无需使用vmware即可实现linux系统的解决方案。</p>
<p>演示的电脑为windows11系统，首先安装wsl2。</p>
<p>打开控制面板，选择“程序”&gt;“程序和功能”&gt;“启用或关闭windows功能”。</p>
<p>勾选Hyper-V、适用于Linux的Windows子系统、虚拟机平台。点击确定后等待电脑重启进行配置。</p>
<p>选择“系统”&gt;“开发者选项“ ，打开开发者模式。</p>
<p>通过命令行安装Ubuntu发行版，打开Powershell，输入如下命令自动安装最新版Ubuntu。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wsl --install</span><br></pre></td></tr></table></figure>

<p>或者可以通过如下命令查看当前支持的所有发行版并选择安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wsl --list --online</span><br></pre></td></tr></table></figure>

<p>安装完成后会自行启动Ubuntu终端，第一次登陆Ubuntu终端时需创建用户名和密码。<br>通过如下指令可以查看已安装的wsl版本，确认安装的wsl版本为2即可。如果wsl版本为1可自行搜索如何进行wsl版本升级。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wsl -l -v</span><br></pre></td></tr></table></figure>

<p>此时打开文件资源管理器即可看到安装的linux系统的存储位置。<br>运行win+G打开运行，输入wsl.exe即可启动wsl。<br>在wsl中输入如下命令可以获取具体所安装的ubuntu发行版的版本信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release -a</span><br></pre></td></tr></table></figure>

<p>第二部分介绍如何使用vscode启动wsl。<br>vs code就是一个代码编辑器，实际上你一开始打开它确实就是一个记事本。但是我们要知道一种语言的代码能够运行是需要提供一个编译操作的，例如visual studio或者pycharm或者等等IDE其实都是为对应的语言提供了一种开发环境，配置了编译器这些工具。但是vs code的好处就在于它实在是非常轻便，你可以把它想象成一种容器进行随意地扩展，因此vs code可以安装很多扩展功能以支持不同语言不同功能的使用，非常地灵活好用，而且界面也确实挺美观的。<br>我们首先从官网或者Microsoft store下载vs code，打开后可以根据下面这个链接中的文章进行一些比较好用且美观的设置。<br><a target="_blank" rel="noopener" href="https://shandianchengzi.blog.csdn.net/article/details/143104357">https://shandianchengzi.blog.csdn.net/article/details/143104357</a></p>
<p>点击vscode左侧菜单栏最后一个图标进入扩展，或者输入快捷键Ctrl + Shift + X打开扩展，搜索wsl扩展程序并安装。<br>安装完成后点击左下角打开远程窗口，选择连接到wsl即可进入远程窗口。<br>点击最顶部的菜单栏的“终端”&gt;“新建终端”，即可打开linux系统的bash命令行窗口进行操作。<br>查看此时的扩展程序，可以发现wsl和本地的扩展程序是分开的，实质上就可理解为我们通过wsl构建了一个linux系统，以后所有的代码工作和环境配置都会在wsl中进行。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Qiu Junpeng</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
